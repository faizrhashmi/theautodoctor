# CRITICAL: Session Rejoin Vulnerability Report

**Date**: 2025-11-03
**Severity**: ðŸ”´ **CRITICAL**
**Issue ID**: SESSION-REJOIN-001
**Status**: âš ï¸ **UNPATCHED - NEEDS IMMEDIATE FIX**

---

## Executive Summary

A **critical security vulnerability** allows users to rejoin sessions that have already been ended by either participant. When a user presses the browser back button after a session ends, they can re-enter the session room, even though the session status is marked as "completed" in the database. This breaks the fundamental session lifecycle and creates several serious problems.

---

## The Problem

### User Flow (Current Behavior - BROKEN):
```
1. Customer and Mechanic are in a video/chat session
2. Mechanic clicks "End Session"
   â”œâ”€ API marks session status as 'completed' âœ…
   â”œâ”€ API broadcasts 'session:ended' event âœ…
   â””â”€ Both users see completion modal âœ…

3. Both users click "Go to Dashboard"
   â””â”€ Redirected to their respective dashboards âœ…

4. âš ï¸ Either user clicks browser BACK button
   â”œâ”€ Browser navigates to /video/{id} or /chat/{id}
   â”œâ”€ Page loads successfully (NO STATUS CHECK) âŒ
   â”œâ”€ LiveKit room reconnection allowed âŒ
   â””â”€ User is back in the "ended" session âŒ CRITICAL BUG
```

### What Should Happen:
```
4. User clicks browser BACK button
   â”œâ”€ Page.tsx checks session.status
   â”œâ”€ Detects status === 'completed'
   â””â”€ Redirects to dashboard OR shows "Session Already Ended" page
```

---

## Root Cause Analysis

### Files Affected:

#### 1. **src/app/video/[id]/page.tsx** (Lines 61-73)
**Problem**: No session status validation

```typescript
// CURRENT CODE (VULNERABLE):
const { data: session, error: sessionError } = await supabase
  .from('sessions')
  .select('id, plan, type, status, metadata, created_at, started_at, ended_at, mechanic_id, customer_user_id')
  .eq('id', sessionId)
  .maybeSingle()

if (sessionError) {
  throw new Error(sessionError.message)
}

if (!session || session.type !== 'video') {
  notFound()
}

// âŒ MISSING: No check for session.status === 'completed' or 'cancelled'
// Code continues and renders VideoSessionClient even for ended sessions!
```

**What's Missing**:
```typescript
// After line 73, should add:
if (session.status === 'completed' || session.status === 'cancelled') {
  // Session has ended - prevent access
  redirect(dashboardUrl) // or notFound() with error message
}
```

#### 2. **src/app/chat/[id]/page.tsx** (Lines 61-73)
**Problem**: Identical vulnerability - no session status validation

```typescript
// CURRENT CODE (VULNERABLE):
const { data: session, error: sessionError } = await supabase
  .from('sessions')
  .select('id, plan, type, status, metadata, created_at, started_at, mechanic_id, customer_user_id')
  .eq('id', sessionId)
  .maybeSingle()

if (sessionError) {
  throw new Error(sessionError.message)
}

if (!session || session.type !== 'chat') {
  notFound()
}

// âŒ MISSING: Same vulnerability - no status check
```

#### 3. **src/app/video/[id]/VideoSessionClient.tsx** (Line 47)
**Problem**: Receives `status` prop but never validates it

```typescript
interface VideoSessionClientProps {
  sessionId: string
  userId: string
  userRole: 'mechanic' | 'customer'
  plan: PlanKey
  planName: string
  token: string
  serverUrl: string
  status: string  // âŒ Received but never used for validation!
  startedAt: string | null
  mechanicId: string | null
  customerId: string | null
  dashboardUrl: string
}

// Component renders LiveKit room WITHOUT checking if status is 'completed'
// Allows reconnection to ended sessions
```

---

## The Broadcast Mechanism (Working Correctly)

### When Session Ends:

**API Endpoint**: `POST /api/sessions/[id]/end` (route.ts:42-795)

**What Happens** (Lines 644-677):
```typescript
// 1. Updates session status to 'completed'
await supabaseAdmin
  .from('sessions')
  .update({
    status: 'completed',
    ended_at: now,
    duration_minutes: durationMinutes,
  })
  .eq('id', sessionId)

// 2. Broadcasts to session-specific channel
const channelName = session.type === 'chat'
  ? `session-${sessionId}`
  : `session:${sessionId}`

await supabaseAdmin.channel(channelName).send({
  type: 'broadcast',
  event: 'session:ended',
  payload: {
    sessionId,
    status: 'completed',
    ended_at: now,
    duration_minutes: durationMinutes,
    endedBy: isCustomer ? 'customer' : 'mechanic',
  },
})

// 3. Also broadcasts to global channel
await supabaseAdmin.channel('active-sessions-updates').send({
  type: 'broadcast',
  event: 'session_completed',
  payload: {
    session_id: sessionId,
    status: 'completed',
    ended_at: now,
  },
})
```

### Broadcast Listener (VideoSessionClient.tsx Lines 833-880):

```typescript
useEffect(() => {
  const channel = supabase
    .channel(`session:${sessionId}`)
    .on('broadcast', { event: 'session:ended' }, async (payload) => {
      console.log('[VIDEO] ðŸ“¡ Session ended by other participant:', payload)
      const { status } = payload.payload

      if (status === 'cancelled') {
        alert('Session has been cancelled by the other participant.')
        setTimeout(() => {
          window.location.href = dashboardUrl
        }, 2000)
      } else {
        // Shows completion modal
        await fetchAndShowCompletionModal()
      }
    })
    .subscribe()

  return () => {
    supabase.removeChannel(channel)
  }
}, [sessionId, dashboardUrl, supabase])
```

**This works correctly ONLY while both participants are connected to the LiveKit room.**

---

## Why the Bug Happens

### Timeline:

```
T+0:   Session active - both participants connected to LiveKit room
T+1:   Mechanic clicks "End Session"
T+2:   API updates status to 'completed' in database âœ…
T+3:   API broadcasts 'session:ended' âœ…
T+4:   Both clients receive broadcast âœ…
T+5:   Both see completion modal âœ…
T+6:   Broadcast listener cleanup (channel unsubscribed) âœ…
T+7:   Both navigate to dashboards âœ…

--- USER CLICKS BROWSER BACK BUTTON ---

T+8:   Browser requests GET /video/{id}
T+9:   page.tsx runs on server (fresh request) âŒ
T+10:  Fetches session from database
        â””â”€ session.status === 'completed' â† This is in DB!
T+11:  âŒ BUG: No validation of session.status
T+12:  Passes all data to VideoSessionClient
T+13:  VideoSessionClient renders LiveKit room
T+14:  User reconnects to LiveKit with valid token âŒ
T+15:  User is back in "ended" session âŒ
```

### Why Real-time Listener Doesn't Help:

The broadcast listener (lines 833-880) **only works if you're already in the room**. When a user navigates back via browser:

1. **Fresh page load** = Fresh component mount
2. **New broadcast subscription** is created
3. **No broadcast is sent** (session was already ended)
4. Listener sits idle waiting for events that will never come
5. User stays in the room indefinitely

---

## Security & Business Impact

### 1. **Data Integrity** ðŸ”´
- Session marked as `completed` in database
- Duration already calculated and stored
- Payout already processed to mechanic
- But users can still communicate!

### 2. **Billing Issues** ðŸ”´
- Customer already charged for session
- Mechanic already paid
- Any additional time is FREE for customer
- Mechanic working for free
- No tracking of post-completion time

### 3. **Analytics Corruption** ðŸŸ¡
- Session duration in DB doesn't match actual time
- "Completed" sessions show as still active in LiveKit
- Metrics and reports become unreliable

### 4. **Customer Experience** ðŸŸ¡
- Confusion: "Why can I rejoin an ended session?"
- Inconsistent UX: Dashboard shows "completed" but room accessible
- Loss of trust in platform

### 5. **Mechanic Experience** ðŸŸ¡
- Mechanic assumes session is over
- Customer rejoins and expects continued service
- Mechanic not compensated for extra time
- Potential conflict and poor reviews

### 6. **LiveKit Resource Waste** ðŸŸ¢
- Ended sessions remain open in LiveKit
- Media server resources not freed
- Unnecessary bandwidth consumption

---

## Reproduction Steps

### Prerequisites:
- One active session (video or chat)
- Two participants (customer + mechanic)

### Steps:
```
1. Start a session (video or chat)
2. As mechanic OR customer, click "End Session"
3. Observe completion modal appears âœ…
4. Click "Go to Dashboard" âœ…
5. Observe redirect to dashboard âœ…
6. Click browser BACK button (or manually navigate to /video/{id})
7. âš ï¸ BUG: Page loads successfully
8. âš ï¸ BUG: LiveKit room reconnects
9. âš ï¸ BUG: You're back in the "completed" session
```

**Expected**: Step 6 should redirect to dashboard or show "Session Ended" page
**Actual**: Step 7-9 allow full reconnection

---

## Solution Design (No Breaking Changes)

### Principle: **Defense in Depth**
Implement validation at multiple layers:

#### Layer 1: Server-Side Page Validation (PRIMARY FIX)
**File**: `src/app/video/[id]/page.tsx` and `src/app/chat/[id]/page.tsx`

```typescript
// AFTER line 73 (after checking session type):

// âœ… SECURITY: Prevent access to completed/cancelled sessions
if (session.status === 'completed' || session.status === 'cancelled') {
  console.log(`[VIDEO PAGE SECURITY] Session ${sessionId} is ${session.status} - redirecting to dashboard`)

  // Determine dashboard URL based on user role
  const isMechanicForThisSession = mechanic && session.mechanic_id === mechanic.id
  const dashboardUrl = isMechanicForThisSession
    ? '/mechanic/dashboard'
    : '/customer/dashboard'

  redirect(dashboardUrl)
}
```

**Why This Works**:
- Runs on server-side (can't be bypassed by client)
- Checks database truth (not client state)
- Prevents component from even rendering
- Works for browser back button, direct URL access, bookmarks, etc.

#### Layer 2: Client-Side Effect Validation (BACKUP)
**File**: `src/app/video/[id]/VideoSessionClient.tsx`

Add this useEffect near the top of the component:

```typescript
// Add near line 780 (after status prop destructuring):

// âœ… BACKUP VALIDATION: Redirect if status is completed/cancelled
useEffect(() => {
  if (status === 'completed' || status === 'cancelled') {
    console.log(`[VIDEO CLIENT] Session ${sessionId} is ${status} - redirecting to dashboard`)

    // Small delay to avoid hydration issues
    setTimeout(() => {
      window.location.href = dashboardUrl
    }, 100)
  }
}, [status, sessionId, dashboardUrl])
```

**Why This Helps**:
- Catches edge cases if server-side redirect fails
- Provides immediate feedback on client
- Works even if user manually modifies URL

#### Layer 3: Real-time Status Listener (ENHANCEMENT)
**File**: `src/app/video/[id]/VideoSessionClient.tsx`

Add a database listener for status changes:

```typescript
// Add near line 880 (after broadcast listener):

// âœ… DATABASE LISTENER: Monitor session status changes
useEffect(() => {
  console.log('[VIDEO] Setting up session status listener')

  const channel = supabase
    .channel(`db-session-${sessionId}`)
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'sessions',
        filter: `id=eq.${sessionId}`,
      },
      (payload) => {
        console.log('[VIDEO] ðŸ“Š Session updated in database:', payload)
        const newStatus = payload.new.status

        if (newStatus === 'completed' || newStatus === 'cancelled') {
          console.log('[VIDEO] ðŸ“Š Session ended - redirecting to dashboard')

          // Show brief notification
          alert(`Session has been ${newStatus}. Returning to dashboard...`)

          // Redirect to dashboard
          setTimeout(() => {
            window.location.href = dashboardUrl
          }, 1000)
        }
      }
    )
    .subscribe()

  return () => {
    console.log('[VIDEO] Cleaning up status listener')
    supabase.removeChannel(channel)
  }
}, [sessionId, dashboardUrl, supabase])
```

**Why This is Powerful**:
- Detects status changes even if broadcast fails
- Works for all session end scenarios
- Provides real-time protection
- Catches admin interventions (manual session cancellation)

---

## Implementation Plan

### Priority Order:

#### ðŸ”´ P0 - CRITICAL (Deploy Immediately)
**Layer 1**: Server-side validation in page.tsx files
- **Files**: 2 files (video/page.tsx, chat/page.tsx)
- **Lines**: ~6 lines each
- **Time**: 5 minutes
- **Risk**: ZERO - only adds validation
- **Impact**: Fixes 95% of cases

#### ðŸŸ¡ P1 - HIGH (Deploy Same Day)
**Layer 2**: Client-side status validation
- **Files**: 2 files (VideoSessionClient.tsx, ChatRoomV3.tsx)
- **Lines**: ~15 lines each
- **Time**: 10 minutes
- **Risk**: LOW - uses existing props
- **Impact**: Catches edge cases

#### ðŸŸ¢ P2 - MEDIUM (Deploy This Week)
**Layer 3**: Real-time database listener
- **Files**: 2 files (VideoSessionClient.tsx, ChatRoomV3.tsx)
- **Lines**: ~40 lines each
- **Time**: 30 minutes
- **Risk**: LOW - additive only
- **Impact**: Comprehensive protection

### Testing Checklist:

```
âœ… Test Case 1: Browser Back Button
- End session â†’ Dashboard â†’ Back button â†’ Should redirect to dashboard

âœ… Test Case 2: Direct URL Access
- End session â†’ Copy URL â†’ New tab â†’ Paste URL â†’ Should redirect to dashboard

âœ… Test Case 3: Bookmark/History
- End session â†’ Access from browser history â†’ Should redirect to dashboard

âœ… Test Case 4: Manual Status Change
- Admin changes status to 'completed' in DB â†’ User should be kicked immediately

âœ… Test Case 5: Network Delay
- End session with slow network â†’ Ensure no race conditions

âœ… Test Case 6: Multiple Devices
- End on device A â†’ Try to rejoin on device B â†’ Should block

âœ… Test Case 7: Chat vs Video
- Test both session types independently

âœ… Test Case 8: Different End Methods
- Timer expiry
- Manual "End Session" button
- Broadcast from other participant
```

---

## Alternative Rejected Solutions

### âŒ Option A: Disable Browser Back Button
**Why Rejected**:
- Not possible to truly disable
- Poor UX
- Doesn't address direct URL access

### âŒ Option B: Clear History on Redirect
**Why Rejected**:
- Browser security prevents this
- Only works for JavaScript redirects
- Doesn't address bookmarks

### âŒ Option C: One-Time Session Tokens
**Why Rejected**:
- Complex implementation
- Breaks session resumption for network issues
- Over-engineered for this problem

### âŒ Option D: Delete Session on End
**Why Rejected**:
- Loses historical data
- Breaks analytics
- Prevents completion modal from showing data

---

## Code Diff Summary

### Proposed Changes:

```
Modified Files: 4
- src/app/video/[id]/page.tsx (add 8 lines)
- src/app/chat/[id]/page.tsx (add 8 lines)
- src/app/video/[id]/VideoSessionClient.tsx (add 50 lines across 2 layers)
- src/app/chat/[id]/ChatRoomV3.tsx (add 50 lines across 2 layers)

Total Lines Added: ~116
Total Lines Removed: 0
Breaking Changes: NONE
```

---

## Rollout Strategy

### Phase 1: Immediate (Layer 1 Only)
```bash
# 1. Apply server-side validation
# 2. Test on staging with all 8 test cases
# 3. Deploy to production
# 4. Monitor for 24 hours
```

### Phase 2: Same Day (Layer 2)
```bash
# 1. Add client-side validation
# 2. Test on staging
# 3. Deploy to production
# 4. Monitor for 48 hours
```

### Phase 3: This Week (Layer 3)
```bash
# 1. Add database listeners
# 2. Comprehensive testing
# 3. Deploy to production
# 4. Monitor for 1 week
# 5. Mark issue as RESOLVED
```

---

## Monitoring & Alerts

### Metrics to Track:

1. **Session Rejoin Attempts** (Expected: 0 after fix)
   ```sql
   -- Count sessions accessed after completion
   SELECT COUNT(*)
   FROM sessions
   WHERE status IN ('completed', 'cancelled')
     AND updated_at > NOW() - INTERVAL '5 minutes'
   ```

2. **LiveKit Orphaned Rooms** (Should decrease)
   ```sql
   -- Rooms open for completed sessions
   SELECT COUNT(*)
   FROM livekit_rooms lr
   JOIN sessions s ON s.id = lr.session_id
   WHERE s.status = 'completed'
     AND lr.created_at > s.ended_at
   ```

3. **Redirect Logs** (Should see redirects in logs)
   ```typescript
   console.log(`[VIDEO PAGE SECURITY] Session ${sessionId} is ${session.status} - redirecting to dashboard`)
   ```

---

## Conclusion

This is a **critical vulnerability** that:
- âœ… Has a simple, non-breaking fix
- âœ… Can be deployed in minutes
- âœ… Requires no database changes
- âœ… Requires no API changes
- âœ… Maintains all existing functionality

**Recommendation**: Deploy Layer 1 (server-side validation) **IMMEDIATELY** to production.

**Status**: ðŸ”´ **AWAITING APPROVAL TO IMPLEMENT**

---

## Approval Checklist

- [ ] Security team notified
- [ ] Product team notified
- [ ] Layer 1 code review completed
- [ ] Layer 1 tested on staging
- [ ] Layer 1 deployed to production
- [ ] Layer 2 code review completed
- [ ] Layer 2 deployed to production
- [ ] Layer 3 code review completed
- [ ] Layer 3 deployed to production
- [ ] Issue marked as RESOLVED
- [ ] Post-mortem completed

---

**Report Generated**: 2025-11-03
**Last Updated**: 2025-11-03
**Next Review**: After Layer 1 deployment
