import { supabaseAdmin } from '@/lib/supabaseAdmin'
import * as net from 'net'

/**
 * P0-4 FIX: Malware scanning adapter for ClamAV
 * Scans files for viruses before upload to protect users
 */

export interface ScanResult {
  clean: boolean
  infected: boolean
  virus?: string
  engine?: string
  scanned: boolean
}

/**
 * Scan file buffer for malware using ClamAV daemon
 * FAIL-CLOSED: Rejects uploads if scanning unavailable
 */
export async function scanFileForMalware(
  buffer: Buffer,
  filename: string
): Promise<ScanResult> {
  const SCAN_UPLOADS = process.env.SCAN_UPLOADS !== 'false' // Default: true
  const CLAMAV_HOST = process.env.CLAMAV_HOST || 'localhost'
  const CLAMAV_PORT = parseInt(process.env.CLAMAV_PORT || '3310')

  // In development, allow bypass if explicitly disabled
  if (!SCAN_UPLOADS && process.env.NODE_ENV !== 'production') {
    console.warn('[SECURITY] Malware scanning disabled - development only')
    return { clean: true, infected: false, scanned: false }
  }

  // In production, scanning is REQUIRED
  if (process.env.NODE_ENV === 'production' && !SCAN_UPLOADS) {
    throw new Error('Malware scanning cannot be disabled in production')
  }

  try {
    const result = await scanWithClamAV(buffer, filename, CLAMAV_HOST, CLAMAV_PORT)
    return result
  } catch (error) {
    console.error('[SECURITY] Malware scan failed:', error)

    // Log scan failure as security event
    await logSecurityEvent('malware_scan_failed', {
      filename,
      error: error instanceof Error ? error.message : 'Unknown error',
    })

    // FAIL-CLOSED: Reject upload if scan fails
    throw new Error('File scanning unavailable. Upload blocked for security.')
  }
}

/**
 * Scan file using ClamAV daemon via TCP socket
 */
async function scanWithClamAV(
  buffer: Buffer,
  filename: string,
  host: string,
  port: number
): Promise<ScanResult> {
  return new Promise((resolve, reject) => {
    const socket = net.connect(port, host, () => {
      // Send INSTREAM command
      socket.write('zINSTREAM\0')

      // Send file size (4 bytes, network byte order)
      const sizeBuffer = Buffer.alloc(4)
      sizeBuffer.writeUInt32BE(buffer.length, 0)
      socket.write(sizeBuffer)

      // Send file data
      socket.write(buffer)

      // Send zero-length chunk to signal end
      const endBuffer = Buffer.alloc(4)
      endBuffer.writeUInt32BE(0, 0)
      socket.write(endBuffer)
    })

    let response = ''

    socket.on('data', (data) => {
      response += data.toString()
    })

    socket.on('end', () => {
      socket.destroy()

      // Parse ClamAV response
      // Format: "stream: OK" or "stream: <virus name> FOUND"
      if (response.includes('OK')) {
        resolve({
          clean: true,
          infected: false,
          engine: 'ClamAV',
          scanned: true,
        })
      } else if (response.includes('FOUND')) {
        const virusMatch = response.match(/stream: (.+) FOUND/)
        const virusName = virusMatch ? virusMatch[1] : 'Unknown'

        resolve({
          clean: false,
          infected: true,
          virus: virusName,
          engine: 'ClamAV',
          scanned: true,
        })
      } else {
        reject(new Error(`Unexpected ClamAV response: ${response}`))
      }
    })

    socket.on('error', (err) => {
      socket.destroy()
      reject(new Error(`ClamAV connection failed: ${err.message}`))
    })

    socket.setTimeout(30000, () => {
      socket.destroy()
      reject(new Error('ClamAV scan timeout after 30 seconds'))
    })
  })
}

/**
 * Log malware detection to security_events table
 */
export async function logMalwareDetection(details: {
  user_id: string
  session_id?: string
  filename: string
  virus: string
  engine: string
}) {
  try {
    await supabaseAdmin.from('security_events').insert({
      event_type: 'malware_detected',
      user_id: details.user_id,
      session_id: details.session_id,
      metadata: {
        filename: details.filename,
        virus: details.virus,
        engine: details.engine,
        timestamp: new Date().toISOString(),
      },
      severity: 'critical',
      created_at: new Date().toISOString(),
    })

    console.error('[SECURITY ALERT] Malware detected:', details)
  } catch (error) {
    console.error('[SECURITY] Failed to log malware detection:', error)
  }
}

/**
 * Log security event
 */
export async function logSecurityEvent(
  eventType: string,
  metadata: Record<string, any>
) {
  try {
    await supabaseAdmin.from('security_events').insert({
      event_type: eventType,
      metadata,
      severity: 'medium',
      created_at: new Date().toISOString(),
    })
  } catch (error) {
    console.error('[SECURITY] Failed to log security event:', error)
  }
}
